<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photothèque</title>
    <!-- Feuille de style pour Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <!-- Bootstrap CSS pour les badges -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
          crossorigin="anonymous">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .badge {
            margin-right: 3px;
            margin-bottom: 3px;
        }
        .zoom-button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .zoom-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <!-- Bibliothèque Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script>
        // Initialisation de la carte
        const map = L.map('map').setView([46.603354, 1.888334], 6);

        // Ajout d'une couche de tuiles OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Fonction pour déterminer la couleur en fonction de nb_photos
        function getColor(nb_photos) {
            if (nb_photos < 10) return '#FFFF00'; // jaune
            else if (nb_photos < 100) return '#FFCC00'; // jaune-orange
            else if (nb_photos < 500) return '#FF9900'; // orange
            else if (nb_photos < 1000) return '#FF6600'; // orange-rouge
            else if (nb_photos < 5000) return '#FF0000'; // rouge
            else return '#990000'; // rouge-foncé
        }

        // Fonction pour zoomer sur l'emprise d'un polygone
        function zoomToFeature(layer) {
            map.fitBounds(layer.getBounds());
        }

        // Fonction pour créer le contenu de la popup avec des badges
        function createPopupContent(feature, layer) {
            // Fonction pour créer des badges à partir d'une liste séparée par des virgules
            function createBadges(list) {
                return list.split(',').map(item => `<span class="badge bg-primary">${item.trim()}</span>`).join(' ');
            }

            // Ajout d'un identifiant unique pour la couche
            const layerId = L.stamp(layer);

            return `
                <div>
                    <p><strong>Année(s) :</strong> <span class="badge bg-info">${feature.properties.nb_annees}</span> ${createBadges(feature.properties.annees_liste)}</p>
                    <p><strong>Jour(s) :</strong> <span class="badge bg-info">${feature.properties.nb_jours}</span> ${createBadges(feature.properties.jours_liste)}</p>
                    <p><strong>Photo(s) :</strong> <span class="badge bg-info">${feature.properties.nb_photos}</span></p>
                    <button class="zoom-button" onclick="zoomToFeature(window.layer${layerId})">Zoom</button>
                </div>
            `;
        }

        // Fonction pour charger un GeoJSON et l'ajouter à la carte
        function loadGeoJson(url, minZoom, maxZoom) {
            return fetch(url)
                .then(response => response.json())
                .then(data => {
                    return L.geoJSON(data, {
                        style: function(feature) {
                            return {
                                color: getColor(feature.properties.nb_photos),
                                weight: 1,
                                fillColor: getColor(feature.properties.nb_photos),
                                fillOpacity: 0.5
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            const layerId = L.stamp(layer);
                            window[`layer${layerId}`] = layer;
                            layer.on('click', function() {
                                const popupContent = createPopupContent(feature, layer);
                                layer.bindPopup(popupContent).openPopup();
                            });
                        }
                    });
                });
        }

        // Chemins vers les GeoJSON
        const geoJsonFiles = [
            { url: 'hexgrid_500000m.geojson', minZoom: 0, maxZoom: 4 },
            { url: 'hexgrid_050000m.geojson', minZoom: 5, maxZoom: 7 },
            { url: 'hexgrid_005000m.geojson', minZoom: 8, maxZoom: 12 },
            { url: 'hexgrid_000500m.geojson', minZoom: 13, maxZoom: 20 }
        ];

        // Tableau pour stocker les couches GeoJSON
        const geoJsonLayers = [];

        // Chargement initial des GeoJSON
        geoJsonFiles.forEach(file => {
            loadGeoJson(file.url, file.minZoom, file.maxZoom)
                .then(layer => {
                    geoJsonLayers.push({ layer: layer, minZoom: file.minZoom, maxZoom: file.maxZoom });
                    // Ajout initial à la carte si le zoom actuel correspond
                    if (map.getZoom() >= file.minZoom && map.getZoom() <= file.maxZoom) {
                        layer.addTo(map);
                    }
                });
        });

        // Gestion de l'événement de changement de zoom
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            geoJsonLayers.forEach(geoJson => {
                if (currentZoom >= geoJson.minZoom && currentZoom <= geoJson.maxZoom) {
                    if (!map.hasLayer(geoJson.layer)) {
                        geoJson.layer.addTo(map);
                    }
                } else {
                    if (map.hasLayer(geoJson.layer)) {
                        map.removeLayer(geoJson.layer);
                    }
                }
            });
        });
    </script>
</body>
</html>
